{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n\n```toc\n# This code block gets replaced with the TOC\nexclude: Table of Contents\ntight: false\nordered: false\nfrom-heading: 2\nto-heading: 6\nclass-name: \"table-of-contents\"\n```\n\n## Functional Independence\n\nIn order to build a software with effective modular design there is a factor “Functional Independence” which comes into play. The meaning of Functional Independence is that a function is atomic in nature so that it performs only a single task of the software without or with least interaction with other modules. Functional Independence is considered as a sign of growth in modularity i.e., presence of larger functional independence results in a software system of good design and design further affects the quality of the software.\n\n## Cohesion and Coupling\n\nIndependence of modules of a software system can be measured using 2 criteria : Cohesion, and Coupling\n\nCohesion is a measure of the degree to which the elements of the module are functionally related. It is the degree to which all elements directed towards performing a single task are contained in the component. Basically, cohesion is the internal glue that keeps the module together. A good software design will have high cohesion.\n\nCoupling is the measure of the degree of interdependence between the modules. A good software will have low coupling.\n\n## Law of Demeter\n\nThe Law of Demeter states that a object should assume as little as possible about the structure or properties of anything else (including its subcomponents). It was designed to promote loose coupling in software designs. The advantage is that the resulting software tends to be more maintainable and adaptable. Since objects are less dependent on the internal structure of other objects, object implementation can be changed without reworking their callers.\n\n in accordance with the principle of \"information hiding\". It may be viewed as a corollary to the principle of least privilege, which dictates that a module possess only the information and resources necessary for its legitimate purpose.\n","excerpt":"Functional Independence Cohesion and Coupling Law of Demeter Functional Independence In order to build a software with effective modular de…","fields":{"slug":"/2022-01-92-code-consistency/"},"frontmatter":{"date":"Jan 22, 2020","title":"Code consistency","tags":["design"],"update":"Feb 06, 2020"}}},{"node":{"rawMarkdownBody":"\nQuite often I am asked about the top programming books that I'd recommend all software developers should read.\n\nI've finally decided to put together a list of the programming books that I find most beneficial and that I think every programmer should read.\n\n<br/>\n\n\n```toc\n# This code block gets replaced with the TOC\nexclude: Table of Contents\ntight: false\nordered: true\nfrom-heading: 2\nto-heading: 6\nclass-name: \"table-of-contents\"\n```\n## Clean Code: A Handbook of Agile Software Craftsmanship\n\n## Computer Science: An Overview\n\nThis is another one of those books that completely changed the way I wrote code. I can neatly divide my programming career into pre-Code Complete, pre-Clean Code and after. I recommend this book after reading Code Complete, because while Code Complete deals more with the structure of individual lines of code and methods, Clean Code deals with some of the same concepts, but at a slightly higher level.\n\nIt's pretty difficult to read this book and not become a better programmer.\n","excerpt":"Quite often I am asked about the top programming books that I'd recommend all software developers should read. I've finally decided to put …","fields":{"slug":"/bookshelf/"},"frontmatter":{"date":"Jan 22, 2020","title":"Bookshelf","tags":["books"],"update":"Feb 06, 2020"}}},{"node":{"rawMarkdownBody":"\n\n```toc\n# This code block gets replaced with the TOC\nexclude: Table of Contents\ntight: false\nordered: false\nfrom-heading: 2\nto-heading: 6\nclass-name: \"table-of-contents\"\n```\n\n## Functional Independence\n\nIn order to build a software with effective modular design there is a factor “Functional Independence” which comes into play. The meaning of Functional Independence is that a function is atomic in nature so that it performs only a single task of the software without or with least interaction with other modules. Functional Independence is considered as a sign of growth in modularity i.e., presence of larger functional independence results in a software system of good design and design further affects the quality of the software.\n\n## Cohesion and Coupling\n\nIndependence of modules of a software system can be measured using 2 criteria : Cohesion, and Coupling\n\nCohesion is a measure of the degree to which the elements of the module are functionally related. It is the degree to which all elements directed towards performing a single task are contained in the component. Basically, cohesion is the internal glue that keeps the module together. A good software design will have high cohesion.\n\nCoupling is the measure of the degree of interdependence between the modules. A good software will have low coupling.\n\n## Law of Demeter\n\nThe Law of Demeter states that a object should assume as little as possible about the structure or properties of anything else (including its subcomponents). It was designed to promote loose coupling in software designs. The advantage is that the resulting software tends to be more maintainable and adaptable. Since objects are less dependent on the internal structure of other objects, object implementation can be changed without reworking their callers.\n\nExample: for any Class C, a method M in C can only invoke the following:\n- arguments in M\n- C and its fields\n- Any instances of C\n- Global Variables\n\nEssentially, this means that method M can only talk to its direct “friends” (in this case are immediate objects and variables) but are not allowed to talk strangers (other unrelated objects or indirect objects).\n\nLaw of Demeter may be viewed as a corollary to the principle of least privilege, which dictates that a module possess only the information and resources necessary for its legitimate purpose.\n","excerpt":"Functional Independence Cohesion and Coupling Law of Demeter Functional Independence In order to build a software with effective modular de…","fields":{"slug":"/2022-01-92-modular-design/"},"frontmatter":{"date":"Jan 22, 2020","title":"Modular Design","tags":["design"],"update":"Feb 06, 2020"}}},{"node":{"rawMarkdownBody":"\nSOLID is a mnemonic abbreviation for a set of design principles created for software development in object-oriented languages.\n\n<br/>\n\n\n```toc\n# This code block gets replaced with the TOC\nexclude: Table of Contents\ntight: false\nordered: false\nfrom-heading: 2\nto-heading: 6\nclass-name: \"table-of-contents\"\n```\n\n\n\n## ES201 The Single-Responsibility Principle (SRP)\n\nThe Single Responsibility Principle requires that a class should have only one job.\n\n```python\n\nclass Order:\n\n    def __init__(self):\n        self.items = []\n        self.quantities = []\n        self.prices = []\n        self.status = \"open\"\n\n    def add_item(self, name, quantity, price):\n        self.items.append(name)\n        self.quantities.append(quantity)\n        self.prices.append(price)\n\n    def total_price(self):\n        total = 0\n        for i in range(len(self.prices)):\n            total += self.quantities[i] * self.prices[i]\n        return total\n\n    def pay(self, payment_type, security_code):\n        if payment_type == \"debit\":\n            print(\"Processing debit payment type\")\n            print(f\"Verifying security code: {security_code}\")\n            self.status = \"paid\"\n        elif payment_type == \"credit\"\n```\n\n```python\n\nclass Order:\n\n    def __init__(self):\n        self.items = []\n        self.quantities = []\n        self.prices = []\n        self.status = \"open\"\n\n    def add_item(self, name, quantity, price):\n        self.items.append(name)\n        self.quantities.append(quantity)\n        self.prices.append(price)\n\n    def total_price(self):\n        total = 0\n        for i in range(len(self.prices)):\n            total += self.quantities[i] * self.prices[i]\n        return total\n\nclass PaymentProcessor:\n    def pay_debit(self, order, security_code):\n        print(\"Processing debit payment type\")\n        print(f\"Verifying security code: {security_code}\")\n        order.status = \"paid\"\n\n    def pay_credit(self, order, security_code):\n        print(\"Processing credit payment type\")\n        print(f\"Verifying security code: {security_code}\")\n        order.status = \"paid\"\n\n\norder = Order()\norder.add_item(\"Keyboard\", 1, 50)\norder.add_item(\"SSD\", 1, 150)\norder.add_item(\"USB cable\", 2, 5)\n\nprint(order.total_price())\nprocessor = PaymentProcessor()\nprocessor.pay_debit(order, \"0372846\")\n```\n\n## ES201 The Open-Closed Principle (OCP)\n\n```python\nclass Order:\n\n    def __init__(self):\n        self.items = []\n        self.quantities = []\n        self.prices = []\n        self.status = \"open\"\n\n    def add_item(self, name, quantity, price):\n        self.items.append(name)\n        self.quantities.append(quantity)\n        self.prices.append(price)\n\n    def total_price(self):\n        total = 0\n        for i in range(len(self.prices)):\n            total += self.quantities[i] * self.prices[i]\n        return total\n\nclass PaymentProcessor:\n    def pay_debit(self, order, security_code):\n        print(\"Processing debit payment type\")\n        print(f\"Verifying security code: {security_code}\")\n        order.status = \"paid\"\n\n    def pay_credit(self, order, security_code):\n        print(\"Processing credit payment type\")\n        print(f\"Verifying security code: {security_code}\")\n        order.status = \"paid\"\n\n\norder = Order()\norder.add_item(\"Keyboard\", 1, 50)\norder.add_item(\"SSD\", 1, 150)\norder.add_item(\"USB cable\", 2, 5)\n\nprint(order.total_price())\nprocessor = PaymentProcessor()\nprocessor.pay_debit(order, \"0372846\")\n```\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Order:\n\n    def __init__(self):\n        self.items = []\n        self.quantities = []\n        self.prices = []\n        self.status = \"open\"\n\n    def add_item(self, name, quantity, price):\n        self.items.append(name)\n        self.quantities.append(quantity)\n        self.prices.append(price)\n\n    def total_price(self):\n        total = 0\n        for i in range(len(self.prices)):\n            total += self.quantities[i] * self.prices[i]\n        return total\n\n\n\nclass PaymentProcessor(ABC):\n\n    @abstractmethod\n    def pay(self, order, security_code):\n        pass\n\nclass DebitPaymentProcessor(PaymentProcessor):\n    def pay(self, order, security_code):\n        print(\"Processing debit payment type\")\n        print(f\"Verifying security code: {security_code}\")\n        order.status = \"paid\"\n\nclass CreditPaymentProcessor(PaymentProcessor):\n    def pay(self, order, security_code):\n        print(\"Processing credit payment type\")\n        print(f\"Verifying security code: {security_code}\")\n        order.status = \"paid\"\n\n\norder = Order()\norder.add_item(\"Keyboard\", 1, 50)\norder.add_item(\"SSD\", 1, 150)\norder.add_item(\"USB cable\", 2, 5)\n\nprint(order.total_price())\nprocessor = DebitPaymentProcessor()\nprocessor.pay(order, \"0372846\")\n```\n## ES201 The Liskov Substitution Principle (LSP)\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Order:\n\n    def __init__(self):\n        self.items = []\n        self.quantities = []\n        self.prices = []\n        self.status = \"open\"\n\n    def add_item(self, name, quantity, price):\n        self.items.append(name)\n        self.quantities.append(quantity)\n        self.prices.append(price)\n\n    def total_price(self):\n        total = 0\n        for i in range(len(self.prices)):\n            total += self.quantities[i] * self.prices[i]\n        return total\n\n\n\nclass PaymentProcessor(ABC):\n\n    @abstractmethod\n    def pay(self, order, security_code):\n        pass\n\nclass DebitPaymentProcessor(PaymentProcessor):\n    def pay(self, order, security_code):\n        print(\"Processing debit payment type\")\n        print(f\"Verifying security code: {security_code}\")\n        order.status = \"paid\"\n\nclass CreditPaymentProcessor(PaymentProcessor):\n    def pay(self, order, security_code):\n        print(\"Processing credit payment type\")\n        print(f\"Verifying security code: {security_code}\")\n        order.status = \"paid\"\n```\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Order:\n\n    def __init__(self):\n        self.items = []\n        self.quantities = []\n        self.prices = []\n        self.status = \"open\"\n\n    def add_item(self, name, quantity, price):\n        self.items.append(name)\n        self.quantities.append(quantity)\n        self.prices.append(price)\n\n    def total_price(self):\n        total = 0\n        for i in range(len(self.prices)):\n            total += self.quantities[i] * self.prices[i]\n        return total\n\n\nclass PaymentProcessor(ABC):\n\n    @abstractmethod\n    def pay(self, order):\n        pass\n\nclass DebitPaymentProcessor(PaymentProcessor):\n\n    def __init__(self, security_code):\n        self.security_code = security_code\n\n    def pay(self, order):\n        print(\"Processing debit payment type\")\n        print(f\"Verifying security code: {self.security_code}\")\n        order.status = \"paid\"\n\nclass CreditPaymentProcessor(PaymentProcessor):\n\n    def __init__(self, security_code):\n        self.security_code = security_code\n\n    def pay(self, order):\n        print(\"Processing credit payment type\")\n        print(f\"Verifying security code: {self.security_code}\")\n        order.status = \"paid\"\n\nclass PaypalPaymentProcessor(PaymentProcessor):\n\n    def __init__(self, email_address):\n        self.email_address = email_address\n\n    def pay(self, order):\n        print(\"Processing paypal payment type\")\n        print(f\"Using email address: {self.email_address}\")\n        order.status = \"paid\"\n\n\norder = Order()\norder.add_item(\"Keyboard\", 1, 50)\norder.add_item(\"SSD\", 1, 150)\norder.add_item(\"USB cable\", 2, 5)\n\nprint(order.total_price())\nprocessor = PaypalPaymentProcessor(\"hi@arjancodes.com\")\nprocessor.pay(order)\n```\n## ES201 The Interface Segregation Principle (ISP)\n\n```python{1,4-60}\nfrom abc import ABC, abstractmethod\n\nclass Order:\n\n    def __init__(self):\n        self.items = []\n        self.quantities = []\n        self.prices = []\n        self.status = \"open\"\n\n    def add_item(self, name, quantity, price):\n        self.items.append(name)\n        self.quantities.append(quantity)\n        self.prices.append(price)\n\n    def total_price(self):\n        total = 0\n        for i in range(len(self.prices)):\n            total += self.quantities[i] * self.prices[i]\n        return total\n\n\nclass PaymentProcessor(ABC):\n\n    @abstractmethod\n    def auth_sms(self, code):\n        pass\n\n    @abstractmethod\n    def pay(self, order):\n        pass\n\nclass DebitPaymentProcessor(PaymentProcessor):\n\n    def __init__(self, security_code):\n        self.security_code = security_code\n        self.verified = False\n\n    def auth_sms(self, code):\n        print(f\"Verifying SMS code {code}\")\n        self.verified = True\n\n    def pay(self, order):\n        if not self.verified:\n            raise Exception(\"Not authorized\")\n        print(\"Processing debit payment type\")\n        print(f\"Verifying security code: {self.security_code}\")\n        order.status = \"paid\"\n\nclass CreditPaymentProcessor(PaymentProcessor):\n\n    def __init__(self, security_code):\n        self.security_code = security_code\n\n    def auth_sms(self, code):\n        raise Exception(\"Credit card payments don't support SMS code authorization.\")\n\n    def pay(self, order):\n        print(\"Processing credit payment type\")\n        print(f\"Verifying security code: {self.security_code}\")\n        order.status = \"paid\"\n\nclass PaypalPaymentProcessor(PaymentProcessor):\n\n    def __init__(self, email_address):\n        self.email_address = email_address\n        self.verified = False\n\n    def auth_sms(self, code):\n        print(f\"Verifying SMS code {code}\")\n        self.verified = True\n\n    def pay(self, order):\n        if not self.verified:\n            raise Exception(\"Not authorized\")\n        print(\"Processing paypal payment type\")\n        print(f\"Using email address: {self.email_address}\")\n        order.status = \"paid\"\n\n\norder = Order()\norder.add_item(\"Keyboard\", 1, 50)\norder.add_item(\"SSD\", 1, 150)\norder.add_item(\"USB cable\", 2, 5)\n\nprint(order.total_price())\nprocessor = DebitPaymentProcessor(\"2349875\")\nprocessor.auth_sms(465839)\nprocessor.pay(order)\n```\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Order:\n\n    def __init__(self):\n        self.items = []\n        self.quantities = []\n        self.prices = []\n        self.status = \"open\"\n\n    def add_item(self, name, quantity, price):\n        self.items.append(name)\n        self.quantities.append(quantity)\n        self.prices.append(price)\n\n    def total_price(self):\n        total = 0\n        for i in range(len(self.prices)):\n            total += self.quantities[i] * self.prices[i]\n        return total\n\n\nclass PaymentProcessor(ABC):\n\n    @abstractmethod\n    def pay(self, order):\n        pass\n\nclass PaymentProcessor_SMS(PaymentProcessor):\n\n    @abstractmethod\n    def auth_sms(self, code):\n        pass\n\n    @abstractmethod\n    def pay(self, order):\n        pass\n\nclass DebitPaymentProcessor(PaymentProcessor_SMS):\n\n    def __init__(self, security_code):\n        self.security_code = security_code\n        self.verified = False\n\n    def auth_sms(self, code):\n        print(f\"Verifying SMS code {code}\")\n        self.verified = True\n\n    def pay(self, order):\n        if not self.verified:\n            raise Exception(\"Not authorized\")\n        print(\"Processing debit payment type\")\n        print(f\"Verifying security code: {self.security_code}\")\n        order.status = \"paid\"\n\nclass CreditPaymentProcessor(PaymentProcessor):\n\n    def __init__(self, security_code):\n        self.security_code = security_code\n\n    def pay(self, order):\n        print(\"Processing credit payment type\")\n        print(f\"Verifying security code: {self.security_code}\")\n        order.status = \"paid\"\n\nclass PaypalPaymentProcessor(PaymentProcessor_SMS):\n\n    def __init__(self, email_address):\n        self.email_address = email_address\n        self.verified = False\n\n    def auth_sms(self, code):\n        print(f\"Verifying SMS code {code}\")\n        self.verified = True\n\n    def pay(self, order):\n        if not self.verified:\n            raise Exception(\"Not authorized\")\n        print(\"Processing paypal payment type\")\n        print(f\"Using email address: {self.email_address}\")\n        order.status = \"paid\"\n\n\norder = Order()\norder.add_item(\"Keyboard\", 1, 50)\norder.add_item(\"SSD\", 1, 150)\norder.add_item(\"USB cable\", 2, 5)\n\nprint(order.total_price())\nprocessor = PaypalPaymentProcessor(\"hi@arjancodes.com\")\nprocessor.auth_sms(465839)\nprocessor.pay(order)\n```\n## ES201 The Dependency inversion Principle (DIP)\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Order:\n\n    def __init__(self):\n        self.items = []\n        self.quantities = []\n        self.prices = []\n        self.status = \"open\"\n\n    def add_item(self, name, quantity, price):\n        self.items.append(name)\n        self.quantities.append(quantity)\n        self.prices.append(price)\n\n    def total_price(self):\n        total = 0\n        for i in range(len(self.prices)):\n            total += self.quantities[i] * self.prices[i]\n        return total\n\nclass SMSAuthorizer:\n\n    def __init__(self):\n        self.authorized = False\n\n    def verify_code(self, code):\n        print(f\"Verifying SMS code {code}\")\n        self.authorized = True\n\n    def is_authorized(self) -> bool:\n        return self.authorized\n\n\nclass PaymentProcessor(ABC):\n\n    @abstractmethod\n    def pay(self, order):\n        pass\n\n\nclass DebitPaymentProcessor(PaymentProcessor):\n\n    def __init__(self, security_code, authorizer: SMSAuthorizer):\n        self.security_code = security_code\n        self.authorizer = authorizer\n\n    def pay(self, order):\n        if not self.authorizer.is_authorized():\n            raise Exception(\"Not authorized\")\n        print(\"Processing debit payment type\")\n        print(f\"Verifying security code: {self.security_code}\")\n        order.status = \"paid\"\n\nclass CreditPaymentProcessor(PaymentProcessor):\n\n    def __init__(self, security_code):\n        self.security_code = security_code\n\n    def pay(self, order):\n        print(\"Processing credit payment type\")\n        print(f\"Verifying security code: {self.security_code}\")\n        order.status = \"paid\"\n\nclass PaypalPaymentProcessor(PaymentProcessor):\n\n    def __init__(self, email_address, authorizer: SMSAuthorizer):\n        self.email_address = email_address\n        self.authorizer = authorizer\n\n    def pay(self, order):\n        if not self.authorizer.is_authorized():\n            raise Exception(\"Not authorized\")\n        print(\"Processing paypal payment type\")\n        print(f\"Using email address: {self.email_address}\")\n        order.status = \"paid\"\n\n\norder = Order()\norder.add_item(\"Keyboard\", 1, 50)\norder.add_item(\"SSD\", 1, 150)\norder.add_item(\"USB cable\", 2, 5)\n\nprint(order.total_price())\nauthorizer = SMSAuthorizer()\n# authorizer.verify_code(465839)\nprocessor = PaypalPaymentProcessor(\"hi@arjancodes.com\", authorizer)\nprocessor.pay(order)\n```\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Order:\n\n    def __init__(self):\n        self.items = []\n        self.quantities = []\n        self.prices = []\n        self.status = \"open\"\n\n    def add_item(self, name, quantity, price):\n        self.items.append(name)\n        self.quantities.append(quantity)\n        self.prices.append(price)\n\n    def total_price(self):\n        total = 0\n        for i in range(len(self.prices)):\n            total += self.quantities[i] * self.prices[i]\n        return total\n\nclass Authorizer(ABC):\n    @abstractmethod\n    def is_authorized(self) -> bool:\n        pass\n\n\nclass Authorizer_SMS(Authorizer):\n\n    def __init__(self):\n        self.authorized = False\n\n    def verify_code(self, code):\n        print(f\"Verifying SMS code {code}\")\n        self.authorized = True\n\n    def is_authorized(self) -> bool:\n        return self.authorized\n\nclass Authorizer_Google(Authorizer):\n\n    def __init__(self):\n        self.authorized = False\n\n    def verify_code(self, code):\n        print(f\"Verifying Google auth code {code}\")\n        self.authorized = True\n\n    def is_authorized(self) -> bool:\n        return self.authorized\n\nclass Authorizer_Robot(Authorizer):\n\n    def __init__(self):\n        self.authorized = False\n\n    def not_a_robot(self):\n        self.authorized = True\n\n    def is_authorized(self) -> bool:\n        return self.authorized\n\n\nclass PaymentProcessor(ABC):\n\n    @abstractmethod\n    def pay(self, order):\n        pass\n\n\nclass DebitPaymentProcessor(PaymentProcessor):\n\n    def __init__(self, security_code, authorizer: Authorizer):\n        self.security_code = security_code\n        self.authorizer = authorizer\n\n    def pay(self, order):\n        if not self.authorizer.is_authorized():\n            raise Exception(\"Not authorized\")\n        print(\"Processing debit payment type\")\n        print(f\"Verifying security code: {self.security_code}\")\n        order.status = \"paid\"\n\nclass CreditPaymentProcessor(PaymentProcessor):\n\n    def __init__(self, security_code):\n        self.security_code = security_code\n\n    def pay(self, order):\n        print(\"Processing credit payment type\")\n        print(f\"Verifying security code: {self.security_code}\")\n        order.status = \"paid\"\n\nclass PaypalPaymentProcessor(PaymentProcessor):\n\n    def __init__(self, email_address, authorizer: Authorizer):\n        self.email_address = email_address\n        self.authorizer = authorizer\n\n    def pay(self, order):\n        if not self.authorizer.is_authorized():\n            raise Exception(\"Not authorized\")\n        print(\"Processing paypal payment type\")\n        print(f\"Using email address: {self.email_address}\")\n        order.status = \"paid\"\n\n\norder = Order()\norder.add_item(\"Keyboard\", 1, 50)\norder.add_item(\"SSD\", 1, 150)\norder.add_item(\"USB cable\", 2, 5)\n\nprint(order.total_price())\nauthorizer = Authorizer_Robot()\n# authorizer.verify_code(465839)\nauthorizer.not_a_robot()\nprocessor = PaypalPaymentProcessor(\"hi@arjancodes.com\", authorizer)\nprocessor.pay(order)\n```\n","excerpt":"SOLID is a mnemonic abbreviation for a set of design principles created for software development in object-oriented languages. ES201 The Si…","fields":{"slug":"/solid-principles/"},"frontmatter":{"date":"Jan 22, 2019","title":"SOLID principles","tags":["design","python"],"update":"Feb 06, 2020"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}