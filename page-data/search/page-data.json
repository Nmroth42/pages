{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n```toc\r\n# This code block gets replaced with the TOC\r\nexclude: Table of Contents\r\ntight: false\r\nordered: false\r\nfrom-heading: 2\r\nto-heading: 6\r\nclass-name: \"table-of-contents\"\r\n```\r\n\r\n\r\n##Two Sum\r\n\r\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\r\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\r\nYou can return the answer in any order.\r\n\r\n[description](https://leetcode.com/problems/two-sum/description/), \r\n[solution](https://leetcode.com/problems/two-sum/solutions/2954482/97-63-faster-solution-in-python-and-hash-map/)\r\n\r\nTime complexity: O(n). Space complexity: O(n)\r\n\r\n```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        storage: dict = {}\r\n        for i, item in enumerate(nums):\r\n            missing_num = target-item\r\n            if storage.get(missing_num) is not None:\r\n                return [i, storage.get(missing_num)]\r\n            storage[item] = i\r\n```\r\n","excerpt":"Two Sum Two Sum Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nY…","fields":{"slug":"/2022-01-92-leetcode-archive/"},"frontmatter":{"date":"Dec 22, 2022","title":"LeetCode archive","tags":["algorithms","python"],"update":"Dec 06, 2020"}}},{"node":{"rawMarkdownBody":"\r\n\r\n```toc\r\n# This code block gets replaced with the TOC\r\nexclude: Table of Contents\r\ntight: false\r\nordered: false\r\nfrom-heading: 2\r\nto-heading: 6\r\nclass-name: \"table-of-contents\"\r\n```\r\n\r\n## Functional Independence\r\n\r\nIn order to build a software with effective modular design there is a factor “Functional Independence” which comes into play. The meaning of Functional Independence is that a function is atomic in nature so that it performs only a single task of the software without or with least interaction with other modules. Functional Independence is considered as a sign of growth in modularity i.e., presence of larger functional independence results in a software system of good design and design further affects the quality of the software.\r\n\r\n## Cohesion and Coupling\r\n\r\nIndependence of modules of a software system can be measured using 2 criteria : Cohesion, and Coupling\r\n\r\nCohesion is a measure of the degree to which the elements of the module are functionally related. It is the degree to which all elements directed towards performing a single task are contained in the component. Basically, cohesion is the internal glue that keeps the module together. A good software design will have high cohesion.\r\n\r\nCoupling is the measure of the degree of interdependence between the modules. A good software will have low coupling.\r\n\r\n## Law of Demeter\r\n\r\nThe Law of Demeter states that a object should assume as little as possible about the structure or properties of anything else (including its subcomponents). It was designed to promote loose coupling in software designs. The advantage is that the resulting software tends to be more maintainable and adaptable. Since objects are less dependent on the internal structure of other objects, object implementation can be changed without reworking their callers.\r\n\r\nExample: for any Class C, a method M in C can only invoke the following:\r\n- arguments in M\r\n- C and its fields\r\n- Any instances of C\r\n- Global Variables\r\n\r\nEssentially, this means that method M can only talk to its direct “friends” (in this case are immediate objects and variables) but are not allowed to talk strangers (other unrelated objects or indirect objects).\r\n\r\nLaw of Demeter may be viewed as a corollary to the principle of least privilege, which dictates that a module possess only the information and resources necessary for its legitimate purpose.\r\n","excerpt":"Functional Independence Cohesion and Coupling Law of Demeter Functional Independence In order to build a software with effective modular de…","fields":{"slug":"/2022-01-92-modular-design/"},"frontmatter":{"date":"Dec 22, 2022","title":"Modular Design","tags":["design"],"update":"Feb 06, 2020"}}},{"node":{"rawMarkdownBody":"\r\nSOLID is a mnemonic abbreviation for a set of design principles created for software development in object-oriented languages. test\r\n\r\n<br/>\r\n\r\n\r\n```toc\r\n# This code block gets replaced with the TOC\r\nexclude: Table of Contents\r\ntight: false\r\nordered: false\r\nfrom-heading: 2\r\nto-heading: 6\r\nclass-name: \"table-of-contents\"\r\n```\r\n\r\n\r\n\r\n##The Single-Responsibility Principle (SRP)\r\n\r\nThe Single Responsibility Principle requires that a class should have only one job.\r\nAnother way to say it is that we want classes and methods to have high cohesion. Be responsible for only a single thing and that ensures us that we can reuse them much easier later on.\r\n\r\n```python\r\n\r\nclass Order:\r\n\r\n    def __init__(self):\r\n        self.items = []\r\n        self.quantities = []\r\n        self.prices = []\r\n        self.status = \"open\"\r\n\r\n    def add_item(self, name, quantity, price):\r\n        self.items.append(name)\r\n        self.quantities.append(quantity)\r\n        self.prices.append(price)\r\n\r\n    def total_price(self):\r\n        total = 0\r\n        for i in range(len(self.prices)):\r\n            total += self.quantities[i] * self.prices[i]\r\n        return total\r\n\r\n    def pay(self, payment_type, security_code):\r\n        if payment_type == \"debit\":\r\n            print(\"Processing debit payment type\")\r\n            print(f\"Verifying security code: {security_code}\")\r\n            self.status = \"paid\"\r\n        elif payment_type == \"credit\"\r\n```\r\n\r\nOrder class has way too many responsibilities and we need to fix that.\r\n\r\n```python\r\n\r\nclass Order:\r\n\r\n    def __init__(self):\r\n        self.items = []\r\n        self.quantities = []\r\n        self.prices = []\r\n        self.status = \"open\"\r\n\r\n    def add_item(self, name, quantity, price):\r\n        self.items.append(name)\r\n        self.quantities.append(quantity)\r\n        self.prices.append(price)\r\n\r\n    def total_price(self):\r\n        total = 0\r\n        for i in range(len(self.prices)):\r\n            total += self.quantities[i] * self.prices[i]\r\n        return total\r\n\r\n\r\nclass PaymentProcessor:\r\n\r\n    def pay_debit(self, order, security_code):\r\n        print(\"Processing debit payment type\")\r\n        print(f\"Verifying security code: {security_code}\")\r\n        order.status = \"paid\"\r\n\r\n    def pay_credit(self, order, security_code):\r\n        print(\"Processing credit payment type\")\r\n        print(f\"Verifying security code: {security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\norder = Order()\r\norder.add_item(\"Keyboard\", 1, 50)\r\norder.add_item(\"SSD\", 1, 150)\r\norder.add_item(\"USB cable\", 2, 5)\r\n\r\nprint(order.total_price())\r\nprocessor = PaymentProcessor()\r\nprocessor.pay_debit(order, \"0372846\")\r\n```\r\n\r\nHere we also introduced some coupling.\r\n\r\n##The Open-Closed Principle (OCP)\r\n\r\nSoftware entities (classes, modules, functions) should be open for extension, but not modification.\r\n\r\n```python\r\nclass Order:\r\n\r\n    def __init__(self):\r\n        self.items = []\r\n        self.quantities = []\r\n        self.prices = []\r\n        self.status = \"open\"\r\n\r\n    def add_item(self, name, quantity, price):\r\n        self.items.append(name)\r\n        self.quantities.append(quantity)\r\n        self.prices.append(price)\r\n\r\n    def total_price(self):\r\n        total = 0\r\n        for i in range(len(self.prices)):\r\n            total += self.quantities[i] * self.prices[i]\r\n        return total\r\n\r\n\r\nclass PaymentProcessor:\r\n\r\n    def pay_debit(self, order, security_code):\r\n        print(\"Processing debit payment type\")\r\n        print(f\"Verifying security code: {security_code}\")\r\n        order.status = \"paid\"\r\n\r\n    def pay_credit(self, order, security_code):\r\n        print(\"Processing credit payment type\")\r\n        print(f\"Verifying security code: {security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\norder = Order()\r\norder.add_item(\"Keyboard\", 1, 50)\r\norder.add_item(\"SSD\", 1, 150)\r\norder.add_item(\"USB cable\", 2, 5)\r\n\r\nprint(order.total_price())\r\nprocessor = PaymentProcessor()\r\nprocessor.pay_debit(order, \"0372846\")\r\n```\r\n\r\nNow the issue is if we want to add an extra payment method like bitcoin or apple pay or paypal we have to modify the payment processor class so that violates the open\r\nclosed principle. Optimally what we'd like to do is create a structure of classes and subclasses, so that we can just define a new subclass for each new payment type.\r\n\r\n```python\r\nfrom abc import ABC, abstractmethod\r\n\r\n\r\nclass Order:\r\n\r\n    def __init__(self):\r\n        self.items = []\r\n        self.quantities = []\r\n        self.prices = []\r\n        self.status = \"open\"\r\n\r\n    def add_item(self, name, quantity, price):\r\n        self.items.append(name)\r\n        self.quantities.append(quantity)\r\n        self.prices.append(price)\r\n\r\n    def total_price(self):\r\n        total = 0\r\n        for i in range(len(self.prices)):\r\n            total += self.quantities[i] * self.prices[i]\r\n        return total\r\n\r\n\r\nclass PaymentProcessor(ABC):\r\n\r\n    @abstractmethod\r\n    def pay(self, order, security_code):\r\n        pass\r\n\r\n\r\nclass DebitPaymentProcessor(PaymentProcessor):\r\n\r\n    def pay(self, order, security_code):\r\n        print(\"Processing debit payment type\")\r\n        print(f\"Verifying security code: {security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\nclass CreditPaymentProcessor(PaymentProcessor):\r\n\r\n    def pay(self, order, security_code):\r\n        print(\"Processing credit payment type\")\r\n        print(f\"Verifying security code: {security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\norder = Order()\r\norder.add_item(\"Keyboard\", 1, 50)\r\norder.add_item(\"SSD\", 1, 150)\r\norder.add_item(\"USB cable\", 2, 5)\r\n\r\nprint(order.total_price())\r\nprocessor = DebitPaymentProcessor()\r\nprocessor.pay(order, \"0372846\")\r\n```\r\n\r\nNow we do not violate this open close principle anymore because if we want to add another\r\npayment type like paypal for example we don't have to change the payment processor or the\r\norder anymore.\r\n\r\n##The Liskov Substitution Principle (LSP)\r\n\r\nThe main idea behind the Liskov Substitution Principle is that for any class, the client should be able to use any subclass of the base class without noticing the difference between them, and therefore without any change in the behavior of the program during execution.\r\n\r\n```python\r\nfrom abc import ABC, abstractmethod\r\n\r\n\r\nclass Order:\r\n\r\n    def __init__(self):\r\n        self.items = []\r\n        self.quantities = []\r\n        self.prices = []\r\n        self.status = \"open\"\r\n\r\n    def add_item(self, name, quantity, price):\r\n        self.items.append(name)\r\n        self.quantities.append(quantity)\r\n        self.prices.append(price)\r\n\r\n    def total_price(self):\r\n        total = 0\r\n        for i in range(len(self.prices)):\r\n            total += self.quantities[i] * self.prices[i]\r\n        return total\r\n\r\n\r\nclass PaymentProcessor(ABC):\r\n\r\n    @abstractmethod\r\n    def pay(self, order, security_code):\r\n        pass\r\n\r\n\r\nclass DebitPaymentProcessor(PaymentProcessor):\r\n\r\n    def pay(self, order, security_code):\r\n        print(\"Processing debit payment type\")\r\n        print(f\"Verifying security code: {security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\nclass CreditPaymentProcessor(PaymentProcessor):\r\n\r\n    def pay(self, order, security_code):\r\n        print(\"Processing credit payment type\")\r\n        print(f\"Verifying security code: {security_code}\")\r\n        order.status = \"paid\"\r\n```\r\n\r\n```python\r\nfrom abc import ABC, abstractmethod\r\n\r\n\r\nclass Order:\r\n\r\n    def __init__(self):\r\n        self.items = []\r\n        self.quantities = []\r\n        self.prices = []\r\n        self.status = \"open\"\r\n\r\n    def add_item(self, name, quantity, price):\r\n        self.items.append(name)\r\n        self.quantities.append(quantity)\r\n        self.prices.append(price)\r\n\r\n    def total_price(self):\r\n        total = 0\r\n        for i in range(len(self.prices)):\r\n            total += self.quantities[i] * self.prices[i]\r\n        return total\r\n\r\n\r\nclass PaymentProcessor(ABC):\r\n\r\n    @abstractmethod\r\n    def pay(self, order):\r\n        pass\r\n\r\nclass DebitPaymentProcessor(PaymentProcessor):\r\n\r\n    def __init__(self, security_code):\r\n        self.security_code = security_code\r\n\r\n    def pay(self, order):\r\n        print(\"Processing debit payment type\")\r\n        print(f\"Verifying security code: {self.security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\nclass CreditPaymentProcessor(PaymentProcessor):\r\n\r\n    def __init__(self, security_code):\r\n        self.security_code = security_code\r\n\r\n    def pay(self, order):\r\n        print(\"Processing credit payment type\")\r\n        print(f\"Verifying security code: {self.security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\nclass PaypalPaymentProcessor(PaymentProcessor):\r\n\r\n    def __init__(self, email_address):\r\n        self.email_address = email_address\r\n\r\n    def pay(self, order):\r\n        print(\"Processing paypal payment type\")\r\n        print(f\"Using email address: {self.email_address}\")\r\n        order.status = \"paid\"\r\n\r\n\r\norder = Order()\r\norder.add_item(\"Keyboard\", 1, 50)\r\norder.add_item(\"SSD\", 1, 150)\r\norder.add_item(\"USB cable\", 2, 5)\r\n\r\nprint(order.total_price())\r\nprocessor = PaypalPaymentProcessor(\"hi@arjancodes.com\")\r\nprocessor.pay(order)\r\n```\r\n##The Interface Segregation Principle (ISP)\r\n\r\nMany client-specific interfaces are better than one general-purpose interface\r\n\r\nI've extended this example to now  include a two-factor authentication inside the payment processor class\r\n\r\n```python\r\nfrom abc import ABC, abstractmethod\r\n\r\n\r\nclass Order:\r\n\r\n    def __init__(self):\r\n        self.items = []\r\n        self.quantities = []\r\n        self.prices = []\r\n        self.status = \"open\"\r\n\r\n    def add_item(self, name, quantity, price):\r\n        self.items.append(name)\r\n        self.quantities.append(quantity)\r\n        self.prices.append(price)\r\n\r\n    def total_price(self):\r\n        total = 0\r\n        for i in range(len(self.prices)):\r\n            total += self.quantities[i] * self.prices[i]\r\n        return total\r\n\r\n\r\nclass PaymentProcessor(ABC):\r\n\r\n    @abstractmethod\r\n    def auth_sms(self, code):\r\n        pass\r\n\r\n    @abstractmethod\r\n    def pay(self, order):\r\n        pass\r\n\r\nclass DebitPaymentProcessor(PaymentProcessor):\r\n\r\n    def __init__(self, security_code):\r\n        self.security_code = security_code\r\n        self.verified = False\r\n\r\n    def auth_sms(self, code):\r\n        print(f\"Verifying SMS code {code}\")\r\n        self.verified = True\r\n\r\n    def pay(self, order):\r\n        if not self.verified:\r\n            raise Exception(\"Not authorized\")\r\n        print(\"Processing debit payment type\")\r\n        print(f\"Verifying security code: {self.security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\nclass CreditPaymentProcessor(PaymentProcessor):\r\n\r\n    def __init__(self, security_code):\r\n        self.security_code = security_code\r\n\r\n    def auth_sms(self, code):\r\n        raise Exception(\"Credit card payments don't support SMS code authorization.\")\r\n\r\n    def pay(self, order):\r\n        print(\"Processing credit payment type\")\r\n        print(f\"Verifying security code: {self.security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\nclass PaypalPaymentProcessor(PaymentProcessor):\r\n\r\n    def __init__(self, email_address):\r\n        self.email_address = email_address\r\n        self.verified = False\r\n\r\n    def auth_sms(self, code):\r\n        print(f\"Verifying SMS code {code}\")\r\n        self.verified = True\r\n\r\n    def pay(self, order):\r\n        if not self.verified:\r\n            raise Exception(\"Not authorized\")\r\n        print(\"Processing paypal payment type\")\r\n        print(f\"Using email address: {self.email_address}\")\r\n        order.status = \"paid\"\r\n\r\n\r\norder = Order()\r\norder.add_item(\"Keyboard\", 1, 50)\r\norder.add_item(\"SSD\", 1, 150)\r\norder.add_item(\"USB cable\", 2, 5)\r\n\r\nprint(order.total_price())\r\nprocessor = DebitPaymentProcessor(\"2349875\")\r\nprocessor.auth_sms(465839)\r\nprocessor.pay(order)\r\n```\r\n\r\nHere you see an issue with defining a generic interface like the payment processor to do multiple things that are not always applicable to subclasses.\r\nIn this case not all subclasses support two-factor authentication so it's better to create\r\nseparate interfaces for this and what you could do for example is add a second subclass of payment processor that adds sms two-factor authentication capabilities.\r\n\r\n```python\r\nfrom abc import ABC, abstractmethod\r\n\r\n\r\nclass Order:\r\n\r\n    def __init__(self):\r\n        self.items = []\r\n        self.quantities = []\r\n        self.prices = []\r\n        self.status = \"open\"\r\n\r\n    def add_item(self, name, quantity, price):\r\n        self.items.append(name)\r\n        self.quantities.append(quantity)\r\n        self.prices.append(price)\r\n\r\n    def total_price(self):\r\n        total = 0\r\n        for i in range(len(self.prices)):\r\n            total += self.quantities[i] * self.prices[i]\r\n        return total\r\n\r\n\r\nclass PaymentProcessor(ABC):\r\n\r\n    @abstractmethod\r\n    def pay(self, order):\r\n        pass\r\n\r\nclass PaymentProcessor_SMS(PaymentProcessor):\r\n\r\n    @abstractmethod\r\n    def auth_sms(self, code):\r\n        pass\r\n\r\n    @abstractmethod\r\n    def pay(self, order):\r\n        pass\r\n\r\n\r\nclass DebitPaymentProcessor(PaymentProcessor_SMS):\r\n\r\n    def __init__(self, security_code):\r\n        self.security_code = security_code\r\n        self.verified = False\r\n\r\n    def auth_sms(self, code):\r\n        print(f\"Verifying SMS code {code}\")\r\n        self.verified = True\r\n\r\n    def pay(self, order):\r\n        if not self.verified:\r\n            raise Exception(\"Not authorized\")\r\n        print(\"Processing debit payment type\")\r\n        print(f\"Verifying security code: {self.security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\nclass CreditPaymentProcessor(PaymentProcessor):\r\n\r\n    def __init__(self, security_code):\r\n        self.security_code = security_code\r\n\r\n    def pay(self, order):\r\n        print(\"Processing credit payment type\")\r\n        print(f\"Verifying security code: {self.security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\nclass PaypalPaymentProcessor(PaymentProcessor_SMS):\r\n\r\n    def __init__(self, email_address):\r\n        self.email_address = email_address\r\n        self.verified = False\r\n\r\n    def auth_sms(self, code):\r\n        print(f\"Verifying SMS code {code}\")\r\n        self.verified = True\r\n\r\n    def pay(self, order):\r\n        if not self.verified:\r\n            raise Exception(\"Not authorized\")\r\n        print(\"Processing paypal payment type\")\r\n        print(f\"Using email address: {self.email_address}\")\r\n        order.status = \"paid\"\r\n\r\n\r\norder = Order()\r\norder.add_item(\"Keyboard\", 1, 50)\r\norder.add_item(\"SSD\", 1, 150)\r\norder.add_item(\"USB cable\", 2, 5)\r\n\r\nprint(order.total_price())\r\nprocessor = PaypalPaymentProcessor(\"hi@arjancodes.com\")\r\nprocessor.auth_sms(465839)\r\nprocessor.pay(order)\r\n```\r\n##The Dependency inversion Principle (DIP)\r\n\r\nDependency inversion means i want our classes to depend on abstractions and not on concrete subclasses and in this code this is currently an issue because the payment processes are depending on specific authorizers.\r\n\r\n```python\r\nfrom abc import ABC, abstractmethod\r\n\r\n\r\nclass Order:\r\n\r\n    def __init__(self):\r\n        self.items = []\r\n        self.quantities = []\r\n        self.prices = []\r\n        self.status = \"open\"\r\n\r\n    def add_item(self, name, quantity, price):\r\n        self.items.append(name)\r\n        self.quantities.append(quantity)\r\n        self.prices.append(price)\r\n\r\n    def total_price(self):\r\n        total = 0\r\n        for i in range(len(self.prices)):\r\n            total += self.quantities[i] * self.prices[i]\r\n        return total\r\n\r\n\r\nclass SMSAuthorizer:\r\n\r\n    def __init__(self):\r\n        self.authorized = False\r\n\r\n    def verify_code(self, code):\r\n        print(f\"Verifying SMS code {code}\")\r\n        self.authorized = True\r\n\r\n    def is_authorized(self) -> bool:\r\n        return self.authorized\r\n\r\n\r\nclass PaymentProcessor(ABC):\r\n\r\n    @abstractmethod\r\n    def pay(self, order):\r\n        pass\r\n\r\n\r\nclass DebitPaymentProcessor(PaymentProcessor):\r\n\r\n    def __init__(self, security_code, authorizer: SMSAuthorizer):\r\n        self.security_code = security_code\r\n        self.authorizer = authorizer\r\n\r\n    def pay(self, order):\r\n        if not self.authorizer.is_authorized():\r\n            raise Exception(\"Not authorized\")\r\n        print(\"Processing debit payment type\")\r\n        print(f\"Verifying security code: {self.security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\nclass CreditPaymentProcessor(PaymentProcessor):\r\n\r\n    def __init__(self, security_code):\r\n        self.security_code = security_code\r\n\r\n    def pay(self, order):\r\n        print(\"Processing credit payment type\")\r\n        print(f\"Verifying security code: {self.security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\nclass PaypalPaymentProcessor(PaymentProcessor):\r\n\r\n    def __init__(self, email_address, authorizer: SMSAuthorizer):\r\n        self.email_address = email_address\r\n        self.authorizer = authorizer\r\n\r\n    def pay(self, order):\r\n        if not self.authorizer.is_authorized():\r\n            raise Exception(\"Not authorized\")\r\n        print(\"Processing paypal payment type\")\r\n        print(f\"Using email address: {self.email_address}\")\r\n        order.status = \"paid\"\r\n\r\n\r\norder = Order()\r\norder.add_item(\"Keyboard\", 1, 50)\r\norder.add_item(\"SSD\", 1, 150)\r\norder.add_item(\"USB cable\", 2, 5)\r\n\r\nprint(order.total_price())\r\nauthorizer = SMSAuthorizer()\r\n# authorizer.verify_code(465839)\r\nprocessor = PaypalPaymentProcessor(\"hi@arjancodes.com\", authorizer)\r\nprocessor.pay(order)\r\n```\r\n\r\nTo solve that we need to create another abstract authorizer class that you pass to the payment processors.\r\n\r\n```python\r\nfrom abc import ABC, abstractmethod\r\n\r\n\r\nclass Order:\r\n\r\n    def __init__(self):\r\n        self.items = []\r\n        self.quantities = []\r\n        self.prices = []\r\n        self.status = \"open\"\r\n\r\n    def add_item(self, name, quantity, price):\r\n        self.items.append(name)\r\n        self.quantities.append(quantity)\r\n        self.prices.append(price)\r\n\r\n    def total_price(self):\r\n        total = 0\r\n        for i in range(len(self.prices)):\r\n            total += self.quantities[i] * self.prices[i]\r\n        return total\r\n\r\nclass Authorizer(ABC):\r\n    @abstractmethod\r\n    def is_authorized(self) -> bool:\r\n        pass\r\n\r\n\r\nclass Authorizer_SMS(Authorizer):\r\n\r\n    def __init__(self):\r\n        self.authorized = False\r\n\r\n    def verify_code(self, code):\r\n        print(f\"Verifying SMS code {code}\")\r\n        self.authorized = True\r\n\r\n    def is_authorized(self) -> bool:\r\n        return self.authorized\r\n\r\n\r\nclass Authorizer_Google(Authorizer):\r\n\r\n    def __init__(self):\r\n        self.authorized = False\r\n\r\n    def verify_code(self, code):\r\n        print(f\"Verifying Google auth code {code}\")\r\n        self.authorized = True\r\n\r\n    def is_authorized(self) -> bool:\r\n        return self.authorized\r\n\r\n\r\nclass Authorizer_Robot(Authorizer):\r\n\r\n    def __init__(self):\r\n        self.authorized = False\r\n\r\n    def not_a_robot(self):\r\n        self.authorized = True\r\n\r\n    def is_authorized(self) -> bool:\r\n        return self.authorized\r\n\r\n\r\nclass PaymentProcessor(ABC):\r\n\r\n    @abstractmethod\r\n    def pay(self, order):\r\n        pass\r\n\r\n\r\nclass DebitPaymentProcessor(PaymentProcessor):\r\n\r\n    def __init__(self, security_code, authorizer: Authorizer):\r\n        self.security_code = security_code\r\n        self.authorizer = authorizer\r\n\r\n    def pay(self, order):\r\n        if not self.authorizer.is_authorized():\r\n            raise Exception(\"Not authorized\")\r\n        print(\"Processing debit payment type\")\r\n        print(f\"Verifying security code: {self.security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\nclass CreditPaymentProcessor(PaymentProcessor):\r\n\r\n    def __init__(self, security_code):\r\n        self.security_code = security_code\r\n\r\n    def pay(self, order):\r\n        print(\"Processing credit payment type\")\r\n        print(f\"Verifying security code: {self.security_code}\")\r\n        order.status = \"paid\"\r\n\r\n\r\nclass PaypalPaymentProcessor(PaymentProcessor):\r\n\r\n    def __init__(self, email_address, authorizer: Authorizer):\r\n        self.email_address = email_address\r\n        self.authorizer = authorizer\r\n\r\n    def pay(self, order):\r\n        if not self.authorizer.is_authorized():\r\n            raise Exception(\"Not authorized\")\r\n        print(\"Processing paypal payment type\")\r\n        print(f\"Using email address: {self.email_address}\")\r\n        order.status = \"paid\"\r\n\r\n\r\norder = Order()\r\norder.add_item(\"Keyboard\", 1, 50)\r\norder.add_item(\"SSD\", 1, 150)\r\norder.add_item(\"USB cable\", 2, 5)\r\n\r\nprint(order.total_price())\r\nauthorizer = Authorizer_Robot()\r\n# authorizer.verify_code(465839)\r\nauthorizer.not_a_robot()\r\nprocessor = PaypalPaymentProcessor(\"hi@arjancodes.com\", authorizer)\r\nprocessor.pay(order)\r\n```\r\n","excerpt":"SOLID is a mnemonic abbreviation for a set of design principles created for software development in object-oriented languages. test The Sin…","fields":{"slug":"/solid-principles/"},"frontmatter":{"date":"Jan 22, 2022","title":"SOLID principles","tags":["principles","python"],"update":"Feb 06, 2022"}}},{"node":{"rawMarkdownBody":"\r\n\r\nThis example deals with handling support tickets.\r\nCurrently process tickets has weak cohesion because it's responsible for not only processing the tickets, but also for implementing each of these different strategies\r\n\r\n```python\r\nimport string\r\nimport random\r\nfrom typing import List\r\n\r\n\r\ndef generate_id(length=8):\r\n    # helper function for generating an id\r\n    return ''.join(random.choices(string.ascii_uppercase, k=length))\r\n\r\n\r\nclass SupportTicket:\r\n\r\n    def __init__(self, customer, issue):\r\n        self.id = generate_id()\r\n        self.customer = customer\r\n        self.issue = issue\r\n\r\n\r\nclass CustomerSupport:\r\n\r\n    def __init__(self, processing_strategy: str = \"fifo\"):\r\n        self.tickets = []\r\n        self.processing_strategy = processing_strategy\r\n\r\n    def create_ticket(self, customer, issue):\r\n        self.tickets.append(SupportTicket(customer, issue))\r\n\r\n    def process_tickets(self):\r\n        # if it's empty, don't do anything\r\n        if len(self.tickets) == 0:\r\n            print(\"There are no tickets to process. Well done!\")\r\n            return\r\n\r\n        if self.processing_strategy == \"fifo\":\r\n            for ticket in self.tickets:\r\n                self.process_ticket(ticket)\r\n        elif self.processing_strategy == \"filo\":\r\n            for ticket in reversed(self.tickets):\r\n                self.process_ticket(ticket)\r\n        elif self.processing_strategy == \"random\":\r\n            list_copy = self.tickets.copy()\r\n            random.shuffle(list_copy)\r\n            for ticket in list_copy:\r\n                self.process_ticket(ticket)\r\n\r\n    def process_ticket(self, ticket: SupportTicket):\r\n        print(\"==================================\")\r\n        print(f\"Processing ticket id: {ticket.id}\")\r\n        print(f\"Customer: {ticket.customer}\")\r\n        print(f\"Issue: {ticket.issue}\")\r\n        print(\"==================================\")\r\n\r\n\r\n# create the application\r\napp = CustomerSupport(\"filo\")\r\n\r\n# register a few tickets\r\napp.create_ticket(\"John Smith\", \"My computer makes strange sounds!\")\r\napp.create_ticket(\"Linus Sebastian\", \"I can't upload any videos, please help.\")\r\napp.create_ticket(\"Arjan Egges\", \"VSCode doesn't automatically solve my bugs.\")\r\n\r\n# process the tickets\r\napp.process_tickets()\r\n```\r\n\r\nSolution using functions\r\n\r\n```python\r\nimport string\r\nimport random\r\nfrom typing import List, Callable\r\n\r\n\r\ndef generate_id(length=8):\r\n    # helper function for generating an id\r\n    return ''.join(random.choices(string.ascii_uppercase, k=length))\r\n\r\n\r\nclass SupportTicket:\r\n\r\n    def __init__(self, customer, issue):\r\n        self.id = generate_id()\r\n        self.customer = customer\r\n        self.issue = issue\r\n\r\n\r\ndef fifoOrdering(list: List[SupportTicket]) -> List[SupportTicket]:\r\n    return list.copy()\r\n\r\n\r\ndef filoOrdering(list: List[SupportTicket]) -> List[SupportTicket]:\r\n    list_copy = list.copy()\r\n    list_copy.reverse()\r\n    return list_copy\r\n\r\n\r\ndef randomOrdering(list: List[SupportTicket]) -> List[SupportTicket]:\r\n    list_copy = list.copy()\r\n    random.shuffle(list_copy)\r\n    return list_copy\r\n\r\n\r\ndef blackHoleOrdering(list: List[SupportTicket]) -> List[SupportTicket]:\r\n    return []\r\n\r\n\r\nclass CustomerSupport:\r\n\r\n    def __init__(self):\r\n        self.tickets = []\r\n\r\n    def create_ticket(self, customer, issue):\r\n        self.tickets.append(SupportTicket(customer, issue))\r\n\r\n    def process_tickets(self, ordering: Callable[[List[SupportTicket]], List[SupportTicket]]):\r\n        # create the ordered list\r\n        ticket_list = ordering(self.tickets)\r\n\r\n        # if it's empty, don't do anything\r\n        if len(ticket_list) == 0:\r\n            print(\"There are no tickets to process. Well done!\")\r\n            return\r\n\r\n        # go through the tickets in the list\r\n        for ticket in ticket_list:\r\n            self.process_ticket(ticket)\r\n\r\n    def process_ticket(self, ticket: SupportTicket):\r\n        print(\"==================================\")\r\n        print(f\"Processing ticket id: {ticket.id}\")\r\n        print(f\"Customer: {ticket.customer}\")\r\n        print(f\"Issue: {ticket.issue}\")\r\n        print(\"==================================\")\r\n\r\n\r\n# create the application\r\napp = CustomerSupport()\r\n\r\n# register a few tickets\r\napp.create_ticket(\"John Smith\", \"My computer makes strange sounds!\")\r\napp.create_ticket(\"Linus Sebastian\", \"I can't upload any videos, please help.\")\r\napp.create_ticket(\"Arjan Egges\", \"VSCode doesn't automatically solve my bugs.\")\r\n\r\n# process the tickets\r\napp.process_tickets(blackHoleOrdering)\r\n```\r\n","excerpt":"This example deals with handling support tickets.\nCurrently process tickets has weak cohesion because it's responsible for not only process…","fields":{"slug":"/2022-01-92-strategy-pattern/"},"frontmatter":{"date":"Jan 22, 2022","title":"Strategy pattern","tags":["patterns","python"],"update":"Feb 06, 2022"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}